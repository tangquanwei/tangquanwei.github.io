---
title: 队列
date: 2022-04-13 15:03:47
tags: Data Structure
---

# 队列

## 1. 基于数组的队列

<!-- more -->

```cpp
#ifndef __QUEUE_H__
#define __QUEUE_H__
/**
 * 顺序队列(基于数组)
 *
 */
template <typename T>
class Queue {
private:
	T* a;
	const static int DEFAULT_SIZE = 16;
	int size;
	int rear, front;

public:
	/* 初始化 */
	Queue();
	/**
	 * @param n 队列长度
	 */
	Queue(int n);
	/* 释放空间 */
	~Queue();
	/**
	 * @param t 入队的元素
	 * @return 空间满了?false:true
	 */
	bool enQueue(T t);
	/* 出队 */
	T deQueue();
	/* 取对头 */
	T getHead();
	/* 判断是否为空 */
	bool empty();
};
template <typename T>
Queue<T>::Queue() {
	a = new T[DEFAULT_SIZE];
	memset(a, 0, DEFAULT_SIZE * sizeof(T));
	size = DEFAULT_SIZE;
	rear = front = 0;
}
template <typename T>
Queue<T>::Queue(int n) {
	a = new T[n + 1];
	memset(a, 0, (n + 1) * sizeof(T));
	size = n + 1;
	rear = front = 0;
}
template <typename T>
Queue<T>::~Queue() {
	delete a;
}
template <typename T>
bool Queue<T>::enQueue(T t) {
	if ((rear + 1) % size != front) {
		rear = (rear + 1) % size;
		a[rear] = t;
		return true;
	}
	return false;
}
template <typename T>
T Queue<T>::deQueue() {
	if (rear != front) {
		front = (front + 1) % size;
		return a[front];
	}
	return nullptr;
}
template <typename T>
T Queue<T>::getHead() {
	if (rear != front)
		return a[front];
	return nullptr;
}
template <typename T>
bool Queue<T>::empty() {
	return rear == front ? true : false;
}

#endif
```

## 2. LinkedQueue

```cpp

#ifndef __LINKED_QUEUE_H__
#define __LINKED_QUEUE_H__
template <typename T>
class Node {
public:
	T val;
	Node<T>* next;
	Node(T t) : val(t) {}
};
template <typename T>
class LinkedQueue {
private:
	Node<T>*head, *tail;

public:
	/* 初始化 */
	LinkedQueue();
	/* 析构 */
	~LinkedQueue();
	/* 入队 */
	bool enQueue(T t);
	/* 出队 */
	T deQueue();
	/* 获取头元素 */
	T getHead();
	/* 判空 */
	bool empty();
};
template <typename T>
LinkedQueue<T>::LinkedQueue() {
	head = nullptr;
	tail = nullptr;
}
template <typename T>
LinkedQueue<T>::~LinkedQueue() {
	while (head != nullptr) {
		Node<T> p = head;
		head = head->next;
		delete p;
	}
	tail = nullptr;
}
template <typename T>
bool LinkedQueue<T>::enQueue(T t) {
	Node<T>* node = new Node<T>(t);
	if (head == nullptr) {
		head = node;
		tail = node;
		return true;
	}
	tail->next = node;
	tail = node;
	return true;
}
template <typename T>
T LinkedQueue<T>::deQueue() {
	if (head != nullptr) {
		Node<T>* node = head;
		T val = head->val;
		head = head->next;
		delete node;
		return val;
	}
	return nullptr;
}
template <typename T>
T LinkedQueue<T>::getHead() {
	return head;
}
template <typename T>
bool LinkedQueue<T>::empty() {
	return head == nullptr;
}
#endif

```
